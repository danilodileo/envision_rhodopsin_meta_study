---
title: "ENVISION dataset: Targeted genes analysis on rhodopsin-containing-genomes"
author: "[Danilo Di Leo](https://github.com/danilodileo)"
date: today
format: 
  html:
    toc: true
    toc-title: "Table of Contents"
    toc-depth: 2
    toc-location: left
    number-sections: true
    code-fold: true
    code-summary: "Show Code"
    fig-width: 6
    fig-height: 4
    highlight-style: github
    css: styles.css
editor: visual
subtitle: "Find me on [GitHub](https://github.com/danilodileo)"
---

### Targeted functions analysis

I want to find how these geomes express key genes involved in: - Rhodopsin biosynthesis (carotenoids) - Glyoxylate shunt (Palovaara) - Other possible associated genes (TonB) To do so I noticed that using KO term as output from KOfamscan is not covering all possible target genes because eggnog-mapper is actually able to find more. By merging the results from the two tools, I can get more set of genes to work with. The following chunk will be used to get a new table with most possible number of targeted genes.

koterms: Rhodopsin K04643 - Prd K04641 - Prd K13759 - Xanthorhodopsin

Glyoxylate shunt K01638 - aceB, glcB; Malate_synthase K00024 - malate dehydrogenase K01637 - aceA; isocitrate/methylisocitrate lyase (K01704 - 3-isopropylmalate dehydratase - not relate but might be relevant K01703 - 3-isopropylmalate dehydratase large subunit (leuC) -- not relate but might be relevant K01676 - Fumarate hydratase - not related but might be relevant) K01958 - PC, pyc; pyruvate carboxylase K01595 - PEP / ppc

Control gene K03553 - RecA

Biosynthesis carotenoids: K02291 - Phytoene Synthase CrtB K10027 - Phytoene desaturase CrtI K22502 - Lycopene cyclase CrtY K09844 - carotene hydratase CrtC K21817 - beta carotene blh K13789 - geranyl geranyl idsA

## Aggregate targeted genes for further analysis

```{r Aggregate targeted genes}
#| label: Aggregate-targeted-functions
#| include: false
#| fig-height: 20
#| eval: false

# Rhodopsin genes
counts.rhodo.genomes <- counts.rhodo.genomes %>%
  mutate(KO = if_else(str_detect(pfams, "Bac_rhodopsin"), "K04641", KO),
         KO = if_else(str_detect(KO, "K04641"), "K04643", KO),
         KO = if_else(str_detect(KO, "K13759"), "K04643", KO),
         preferred_name = if_else(str_detect(KO, "K04643"), "prd", preferred_name))
  
# Glyoxilate shunt
counts.rhodo.genomes <- counts.rhodo.genomes %>%
  mutate(KO = if_else(str_detect(preferred_name, "aceB"), "K01638", KO),
         KO = if_else(str_detect(preferred_name, "glcB"), "K01638", KO),
         KO = if_else(str_detect(pfams, "Malate_synthase"), "K01638", KO),
         preferred_name = if_else(str_detect(KO, "K01638"), "glcB", preferred_name),
         preferred_name = if_else(str_detect(KO, "K00024"), "mdh", preferred_name),
         preferred_name = if_else(str_detect(KO, "K01637"), "aceA", preferred_name),
         preferred_name = if_else(str_detect(kegg_ko, "K01958"), "pyc", preferred_name),
         preferred_name = if_else(str_detect(KO, "K01958"), "pyc", preferred_name),
         preferred_name = if_else(str_detect(KO, "K01595"), "ppc", preferred_name),
         preferred_name = if_else(str_detect(kegg_ko, "K01595"), "ppc", preferred_name))

# Carotenoids
counts.rhodo.genomes <- counts.rhodo.genomes %>%
  rename( ko_definition = 'KO definition') %>%
  mutate(preferred_name = if_else(str_detect(KO, "K02291"), "crtB", preferred_name),
         preferred_name = if_else(str_detect(kegg_ko, "K02291"), "crtB", preferred_name),
         preferred_name = if_else(str_detect(kegg_ko, "K02291"), "crtB", preferred_name),
         preferred_name = if_else(str_detect(ko_definition, "phytoene synthase"), "crtB", preferred_name),
         preferred_name = if_else(str_detect(kegg_ko, "K10027"), "crtI", preferred_name),
         preferred_name = if_else(str_detect(KO, "K10027"), "crtI", preferred_name),
         preferred_name = if_else(str_detect(kegg_ko, "K22502"), "crtY", preferred_name),
         preferred_name = if_else(str_detect(KO, "K22502"), "crtY", preferred_name),
         preferred_name = if_else(str_detect(pfams, "CrtC"), "crtC", preferred_name),
         preferred_name = if_else(str_detect(KO, "K09844"), "crtC", preferred_name),
         preferred_name = if_else(str_detect(KO, "K21817"), "blh", preferred_name),
         preferred_name = if_else(str_detect(kegg_ko, "K21817"), "blh", preferred_name),
         preferred_name = if_else(str_detect(pfams, "BCD"), "blh", preferred_name),
         preferred_name = if_else(str_detect(KO, "K13789"), "idsA", preferred_name),
         preferred_name = if_else(str_detect(kegg_ko, "K13789"), "idsA", preferred_name))


carotenoids <- c("crtB", "crtI", "crtY", "blh", "idsA", "prd", "recA")

palovaara <- c("glcB", "mdh", "aceA", "pyc", "ppc", "recA", "prd")

all_genes <- c(carotenoids,palovaara)

```

## Heatmap for all genomes and indipendent from season and sites

```{r Heatmap for all genomes and indipendent from season and sites, include=FALSE }
#| eval: false

# Create a table for selected genes to correlate - individual abundance dataset
df_season <- individual.abundance %>%
  inner_join(top50genomes, join_by(genome)) %>%
  filter( preferred_name %in% all_genes ) %>%
  group_by( sample, season, site, day, preferred_name, genome ) %>%
  summarise( tpm = sum(tpm), .groups = 'drop') %>%
  select( sample, season, site, day, preferred_name, genome, tpm) %>%
  pivot_wider(names_from = preferred_name, values_from = tpm, values_fill = 0) %>%
  group_by(genome, season, site, day) %>%
  summarise(across(all_of(intersect(colnames(.), 
                    c("crtB", "crtI", "crtY", "blh", "idsA", "recA", 
                      "glcB", "mdh", "aceA", "pyc", "ppc", "prd"))), 
                   \(x) mean(x, na.rm = TRUE)), 
            .groups = "drop")

# Create a table for selected genes to correlate - counts-rhodo-genomes dataset
df_counts.rhodo.genomes <- counts.rhodo.genomes %>%
  inner_join(top50genomes, join_by(genome)) %>%
  filter( preferred_name %in% all_genes ) %>%
  group_by( sample, season, site, day, preferred_name, genome ) %>%
  summarise( tpm = sum(tpm), .groups = 'drop') %>%
  select( sample, season, site, day, preferred_name, genome, tpm) %>%
  pivot_wider(names_from = preferred_name, values_from = tpm, values_fill = 0) %>%
  group_by(genome, season, site, day) %>%
  summarise(across(all_of(intersect(colnames(.), 
                    c("crtB", "crtI", "crtY", "blh", "idsA", "recA", 
                      "glcB", "mdh", "aceA", "pyc", "ppc", "prd"))), 
                   \(x) mean(x, na.rm = TRUE)), 
            .groups = "drop")

# Make a pairwise correlation
df_corr <- cor(df_counts.rhodo.genomes %>% select(-genome, -season, -site, -day), use = "pairwise.complete.obs")
melted_corr <- melt(df_corr)

# Heatmap for all genomes and indipendent from season and sites
p0 <- ggplot(melted_corr, aes(Var1, Var2, fill = value)) +
  geom_tile(color = 'black') +
  scale_fill_gradient2(low = "blue", mid = "white", high = "red", midpoint = 0) +
  theme_minimal() +
  labs(title = "Gene Expression Correlation Heatmap across all samples for all genomes")

# Crt genes seems corelated but no major correlation with rhodopsin
p0
# ggsave(filename = 'gene_expression_correlation_heatmap_site_independent.jpeg', p0)
```

No significant correlation but overall it looks like there are some patterns among crt genes and anaplerotic enzymes, little bit with rhodopsin.

## Heatmap for all genomes and dipendent from season and sites

```{r Heatmap for all genomes and dipendent from season and sites, echo=FALSE, include=FALSE }
#| eval: false
# Function to compute correlation + significance
compute_corr_with_pval <- function(df, group_name) {
  genes <- c("crtB", "crtI", "crtY", "crtC", "blh", "idsA", "recA", 
             "glcB", "mdh", "aceA", "pyc", "ppc", "prd")

  # Extract numeric columns
  df_numeric <- df %>% select(all_of(genes))

  # Get all gene pairs
  gene_pairs <- expand.grid(Var1 = genes, Var2 = genes, stringsAsFactors = FALSE)
  
  # Compute correlation & significance for each pair
  results <- gene_pairs %>%
    rowwise() %>%
    mutate(
      cor_value = cor(df_numeric[[Var1]], df_numeric[[Var2]], use = "pairwise.complete.obs"),
      p_value = cor.test(df_numeric[[Var1]], df_numeric[[Var2]], method = "pearson")$p.value,
      significance = case_when(
        p_value < 0.001 ~ "***",
        p_value < 0.01  ~ "**",
        p_value < 0.05  ~ "*",
        TRUE            ~ ""
      ),
      group = group_name  # Store season+site
    ) %>%
    ungroup()

  return(results)
}

# Split by season & site
df_list <- split(df_counts.rhodo.genomes, list(df_counts.rhodo.genomes$season, df_counts.rhodo.genomes$site), drop = TRUE)

# Compute correlations for all groups
corr_list <- lapply(names(df_list), function(group) {
  df_subset <- df_list[[group]]
  if (nrow(df_subset) < 2) return(NULL)  # Skip if insufficient data
  compute_corr_with_pval(df_subset, group)
})

# Combine all results
df_corr <- bind_rows(corr_list)
df_corr <- df_corr %>%
  separate(group, into = c("season", "site"), sep = "\\.") %>%  # Extract season & site info
  filter(as.character(Var1) < as.character(Var2))  # Keep only upper triangle

p1 <- ggplot(df_corr, aes(Var1, Var2, fill = cor_value)) +
  geom_tile(color = 'black') +
  geom_text(aes(label = significance), color = "black", size = 4) +  # Add stars
  scale_fill_gradient2(low = "blue", mid = "white", high = "red", midpoint = 0) +
  theme_minimal() +
  theme(axis.text.x = element_text(angle = 90, hjust = 1, size = 8) ) +
  labs(title = "Gene Expression Correlation Heatmaps (Season & Site Dependent)",
       fill = "Correlation") +
  facet_wrap(~factor(season, levels = c("Winter", "Spring", "Summer")) + 
               factor(site, levels = c("Offshore", "Coast", "Mesocosm")), 
             scales = "free")


p1
#ggsave(filename = 'gene_expression_correlation_heatmap_season_site_dependent.jpeg', p1)
```

There is an overall increasing of activity going towards summer in all sites. Offshore and mesocosm shows the best correlation. Great response from anaplerotic enzymes and crt genes.

Offshore: genes always linked to recA Coast: winter prd linked to glcB and idsA Mesocosm: Always linked to recA

## Heatmap for all genomes and dipendent from season

```{r Heatmap for all genomes and dipendent from seasons, echo=FALSE, include=FALSE}
#| eval: false
# Split by season
df_list <- split(df_counts.rhodo.genomes, list(df_counts.rhodo.genomes$season), drop = TRUE)

# Compute correlations for all groups
corr_list <- lapply(names(df_list), function(group) {
  df_subset <- df_list[[group]]
  if (nrow(df_subset) < 2) return(NULL)  # Skip if insufficient data
  compute_corr_with_pval(df_subset, group)
})

# Combine all results
df_corr <- bind_rows(corr_list)
df_corr <- df_corr %>%
  separate(group, into = c("season", "site"), sep = "\\.") %>% # Extract season & site info
  filter(as.character(Var1) < as.character(Var2))  # Keep only upper triangle

p2 <- ggplot(df_corr, aes(Var1, Var2, fill = cor_value)) +
  geom_tile(color = 'black') +
  geom_text(aes(label = significance), color = "black", size = 4) +  # Add stars
  scale_fill_gradient2(low = "blue", mid = "white", high = "red", midpoint = 0) +
  theme_minimal() +
  theme(axis.text.x = element_text(angle = 90, hjust = 1, size = 8) ) +
  labs(title = "Gene Expression Correlation Heatmaps (Season Dependent)",
       fill = "Correlation") +
  facet_wrap(~factor(season, levels = c("Winter", "Spring", "Summer")), scales = "free")  # Separate plots for each group

p2
#ggsave(filename = 'gene_expression_correlation_heatmap_season_dependent.jpeg', p2)
```

Despite presence of genes is significant in most seasons, it looks like that toward summer the samples get more expressed for all genes related to rhodopsin biosynthesis and metabolism.

Winter: prd and idsA linked. Spring: aceA and blh linked to prd. Summer: idsA and aceA linked to prd.

## Heatmap for all genomes and dipendent from site

```{r Heatmap for all genomes and dipendent from  sites, include=FALSE }
#| eval: false
# Split by season
df_list <- split(df_counts.rhodo.genomes, list(df_counts.rhodo.genomes$site), drop = TRUE)

# Compute correlations for all groups
corr_list <- lapply(names(df_list), function(group) {
  df_subset <- df_list[[group]]
  if (nrow(df_subset) < 2) return(NULL)  # Skip if insufficient data
  compute_corr_with_pval(df_subset, group)
})

# Combine all results
df_corr <- bind_rows(corr_list)
df_corr <- df_corr %>%
  rename(site = group)  %>% # Extract season & site info
  filter(as.character(Var1) < as.character(Var2))  # Keep only upper triangle

p3 <- ggplot(df_corr, aes(Var1, Var2, fill = cor_value)) +
  geom_tile(color = 'black') +
  geom_text(aes(label = significance), color = "black", size = 4) +  # Add stars
  scale_fill_gradient2(low = "blue", mid = "white", high = "red", midpoint = 0) +
  theme_minimal() +
  labs(title = "Gene Expression Correlation Heatmaps (Site Dependent)",
       fill = "Correlation") +
  theme(axis.text.x = element_text(angle = 90, hjust = 1, size = 8) ) +
  facet_wrap(~factor(site, levels = c("Offshore", "Coast", "Mesocosm")), scales = "free")  # Separate plots for each group

p3
#ggsave(filename = 'gene_expression_correlation_heatmap_site_dependent.jpeg', p3)
```

It looks like there is more pronounced activity in the Offshore site than Coast or mesocosm. Despite most genes related to this group seems more or less correlated.

Offshore: all linked to recA. Coast: crtB and idsA linked to prd. Mesocosm: idsA linked to prd.

## Heatmap for each genome and indipendent from site and season

```{r Heatmap for each genome and indipendent from site and season, include=FALSE }
#| eval: false
# Select only gene columns (assuming all genes start with a pattern like "gene")
gene_cols <- colnames(df_season)[!(colnames(df_season) %in% c("genome", "season", "site"))]

# Identify genomes where only 'prd' is expressed
only_prd_genomes <- df_season %>%
  rowwise() %>%
  filter(prd > 0 & all(c_across(all_of(gene_cols)[gene_cols != "prd"]) == 0 | is.na(c_across(all_of(gene_cols)[gene_cols != "prd"])))) %>%
  distinct(genome)

# Not all genomes from only_prd_genomes have only prd but most of them yest.
# I will remove only those ones.
# Remove those genomes that has only rhodopsin among all genes
toremove <- c('metabat2.1904', 'metabat2.1010', 'metabat2.838', 'GCA_016845715.1', 'GCA_022451725.1', 'metabat2.1304', 'GCA_022426005.1', 'concoct.109', 'metabat2.273')
# Remove the specified genomes from genome_list
genome_list <- df_counts.rhodo.genomes %>% distinct(genome) %>% pull()
genome_list <- setdiff(genome_list, toremove)

# Make sure those genomes are not present in it.
df_season <- df_season %>% filter( genome %in% genome_list)

# Now create a list of df with all genomes
df_list <- split(df_season, df_season$genome)

# Generate now heatmaps based on genomes, site and season
# Heatmaps for each genomes and indipendent from site and season
plot_corr_heatmaps <- function(df_list, output_dir = "indipendent_correlation_single_genomes_heatmaps_norm") {
  # Create directory if it doesn't exist
  if (!dir.exists(output_dir)) dir.create(output_dir)

  heatmaps <- list()

  for (genome_name in names(df_list)) {
    df_genome <- df_list[[genome_name]]
    
    # Remove non-numeric columns
    df_genome_numeric <- df_genome %>% select(-genome, -season, -site, -day)
    if (ncol(df_genome_numeric) < 2) next  # Skip if not enough numeric columns

    # Compute correlation matrix
    corr_matrix <- cor(df_genome_numeric, use = "pairwise.complete.obs")
    
    # Compute p-values
    pval_matrix <- matrix(NA, nrow = ncol(df_genome_numeric), ncol = ncol(df_genome_numeric))
    colnames(pval_matrix) <- colnames(df_genome_numeric)
    rownames(pval_matrix) <- colnames(df_genome_numeric)

    genes <- colnames(df_genome_numeric)
    
    for (i in 1:(length(genes) - 1)) {
      for (j in (i + 1):length(genes)) {
        cor_test <- cor.test(df_genome_numeric[[genes[i]]], df_genome_numeric[[genes[j]]], method = "pearson")
        pval_matrix[i, j] <- cor_test$p.value
        pval_matrix[j, i] <- cor_test$p.value
      }
    }

    # Convert matrices to long format
    melted_corr <- melt(corr_matrix)
    melted_pvals <- melt(pval_matrix)
    
    # Merge correlation and p-value data
    melted_corr$pval <- melted_pvals$value
    melted_corr$significance <- ifelse(melted_corr$pval < 0.001, "***",
                                       ifelse(melted_corr$pval < 0.01, "**",
                                              ifelse(melted_corr$pval < 0.05, "*", "")))
    melted_corr <- melted_corr %>% filter(as.character(Var1) < as.character(Var2))  # Keep only upper triangle
    # Create heatmap
    p <- ggplot(melted_corr, aes(Var1, Var2, fill = value)) +
      geom_tile(color = 'black') +
      geom_text(aes(label = significance), color = "black", size = 5) +
      scale_fill_gradient2(low = "blue", mid = "white", high = "red", midpoint = 0) +
      theme_minimal() +
      labs(title = paste("Gene Expression Correlation indipendent from site and season for",       genome_name),
           fill = "Correlation") +
      theme(plot.title = element_text(size = 9))  # Adjust title size

    heatmaps[[genome_name]] <- p

    # Save plot as JPEG
    ggsave(filename = file.path(output_dir, paste0("correlation_", genome_name, "_indipendent_from_site_and_season.jpeg")),
           plot = p, width = 6, height = 5, dpi = 300)
  }

  return(heatmaps)
}

# Run function and save images
heatmap_plots <- plot_corr_heatmaps(df_list)
```

I kept 16 genomes (normalized genomes) since they have: - enough genes for a comparison - show some correlation (negative of positive) - some of them share patterns.

## Heatmap based on single genomes and dipendent from site

```{r Heatmap based on single genomes and dipendent from site , include=FALSE}
#| eval: false
# Function to compute correlation and significance
compute_correlation <- function(df) {
  cor_matrix <- cor(df, use = "pairwise.complete.obs")
  p_matrix <- matrix(NA, nrow = ncol(df), ncol = ncol(df))
  colnames(p_matrix) <- rownames(p_matrix) <- colnames(df)
  
  for (i in 1:(ncol(df) - 1)) {
    for (j in (i + 1):ncol(df)) {
      test <- cor.test(df[[i]], df[[j]], method = "pearson")
      p_matrix[i, j] <- test$p.value
      p_matrix[j, i] <- test$p.value
    }
  }
  
  melted_corr <- reshape2::melt(cor_matrix)
  melted_pvals <- reshape2::melt(p_matrix)
  melted_corr$pval <- melted_pvals$value
  melted_corr$significance <- ifelse(is.na(melted_corr$pval), "", 
                                   ifelse(melted_corr$pval < 0.001, "***", 
                                          ifelse(melted_corr$pval < 0.01, "**", 
                                                 ifelse(melted_corr$pval < 0.05, "*", ""))))
  melted_corr <- melted_corr %>% filter(as.character(Var1) < as.character(Var2))  # Keep only upper part
  return(melted_corr)
}

# Split data by genome and seasons so the sites are together
df_list <- split(df_season, list(df_season$genome, df_season$season), drop = TRUE)

# Rename list elements to keep only the genome name with its version
names(df_list) <- sub("^([^.]+\\.[0-9]+).*", "\\1", names(df_list))



# Directory to save plots
output_dir <- "heatmaps_site_dependent_norm"
dir.create(output_dir, showWarnings = FALSE)

# Generate heatmaps
for (genome in names(df_list)) {
  df_genome <- df_list[[genome]]
  sites <- unique(df_genome$site)
  plot_list <- list()
  
  print(paste("Processing genome:", genome))  # Debugging
  
  for (site in sites) {
    print(paste("  Checking site:", site))  # Debugging
    df_subset <- df_genome %>% filter(site == !!site) %>% select(-genome, -season, -site, -day)

    if (nrow(df_subset) == 0) {
      print("    No data left after filtering site-specific rows.")
      next
    }

    # Ensure at least 2 genes have valid values
    valid_genes <- df_subset %>% select(where(~ sum(!is.na(.x) & .x != 0) >= 2))
    
    if (ncol(valid_genes) < 2) {
      print("    Not enough genes for correlation analysis.")
      next
    }

    print(paste("    Number of valid genes:", ncol(valid_genes)))  # Debugging

    corr_data <- compute_correlation(valid_genes)
    if (!is.null(corr_data) && nrow(corr_data) > 1) {
        num_significant <- sum(corr_data$significance != "NS")
        print(paste("    Significant correlations found:", num_significant))  # Debugging

        if (num_significant > 0) {
          p <- ggplot(corr_data, aes(Var1, Var2, fill = value)) +
            geom_tile(color = 'black') +
            geom_text(aes(label = significance), color = "black", size = 4) +  
            scale_fill_gradient2(low = "blue", mid = "white", high = "red", midpoint = 0) +
            theme_minimal() +
            labs(title = paste("Site:", site),
                 fill = "Correlation") +
            theme(plot.title = element_text(size = 10),
                  legend.position = 'null')

          plot_list[[site]] <- p
        }
    } else {
        print("    No valid correlation matrix returned.")
    }
  }

  # Arrange plots only if there are valid ones
  num_plots <- length(plot_list)
  print(paste("  Total plots for", genome, ":", num_plots))  # Debugging

  if (num_plots > 0) {
    panel_plot <- wrap_plots(plot_list, ncol = min(num_plots, 3)) +  
      plot_annotation(title = paste("Correlation Heatmaps for", genome)) 

    filename <- paste0(output_dir, "/heatmap_", genome, ".jpeg")
    ggsave(filename = filename, plot = panel_plot, width = 4 * min(num_plots, 3), height = 4)
    print(paste("  Saved heatmap:", filename))  # Debugging
  } else {
    print(paste("  No heatmap saved for genome:", genome))
  }
}

```

Data from site doesn't show any specific pattern. it looks lost without taking account the season.

I kept 12 genomes (normalized genomes) since they have: - enough genes for a comparison - show some correlation (negative of positive) - some of them share patterns.

## Heatmap based on single genomes and dipendent from season

```{r Heatmap based on single genomes and dipendent from season , include=FALSE}
#| eval: false
# Function to compute correlation and significance
compute_correlation <- function(df) {
  cor_matrix <- matrix(NA, nrow = ncol(df), ncol = ncol(df))
  p_matrix <- matrix(NA, nrow = ncol(df), ncol = ncol(df))
  colnames(cor_matrix) <- rownames(cor_matrix) <- colnames(df)
  colnames(p_matrix) <- rownames(p_matrix) <- colnames(df)

  for (i in 1:(ncol(df) - 1)) {
    for (j in (i + 1):ncol(df)) {
      x <- df[[i]]
      y <- df[[j]]
      
      # Remove NA values from both vectors
      valid_idx <- !is.na(x) & !is.na(y)
      x_valid <- x[valid_idx]
      y_valid <- y[valid_idx]

      # Ensure at least 2 valid values exist before running cor.test
      if (length(x_valid) < 2 | length(y_valid) < 2) {
        next  # Skip this correlation pair
      }

      # Try running cor.test, if it fails, return NULL for the genome
      result <- tryCatch({
        test <- cor.test(x_valid, y_valid, method = "pearson")
        cor_matrix[i, j] <- test$estimate
        cor_matrix[j, i] <- test$estimate
        p_matrix[i, j] <- test$p.value
        p_matrix[j, i] <- test$p.value
      }, error = function(e) {
        return(NULL)  # Exit function instead of using next
      })

      if (is.null(result)) return(NULL)  # Skip entire genome on error
    }
  }

  # Remove NA rows/columns to prevent errors in plotting
  if (all(is.na(cor_matrix))) {
    return(NULL)  # Skip this genome completely
  }

  melted_corr <- reshape2::melt(cor_matrix, na.rm = TRUE)  
  melted_pvals <- reshape2::melt(p_matrix, na.rm = TRUE)  
  melted_corr$pval <- melted_pvals$value
  melted_corr$significance <- ifelse(is.na(melted_corr$pval), "",
                                     ifelse(melted_corr$pval < 0.001, "***",
                                            ifelse(melted_corr$pval < 0.01, "**",
                                                   ifelse(melted_corr$pval < 0.05, "*", ""))))
  melted_corr <- melted_corr %>% filter(as.character(Var1) < as.character(Var2))  # Keep only upper part
  return(melted_corr)
}

# Split data by genome and site (now site-dependent)
df_list <- split(df_season, list(df_season$genome, df_season$site), drop = TRUE)

# Rename list elements to keep only the genome name with its version
names(df_list) <- sub("^([^.]+\\.[0-9]+).*", "\\1", names(df_list))

# Directory to save plots
output_dir <- "heatmaps_season_dependent_norm"
dir.create(output_dir, showWarnings = FALSE)

# Generate heatmaps
for (genome in names(df_list)) {
  df_genome <- df_list[[genome]]
  seasons <- unique(df_genome$season)
  plot_list <- list()
  
  print(paste("Processing genome:", genome))  # Debugging
  
  for (season in seasons) {
    print(paste("  Checking season:", season))  # Debugging
    df_subset <- df_genome %>% filter(season == !!season) %>% select(-genome, -season, -site, -day)

    if (nrow(df_subset) == 0) {
      print("    No data left after filtering season-specific rows.")
      next
    }

    # Ensure at least 2 genes have valid values
    valid_genes <- df_subset %>% select(where(~ sum(!is.na(.x) & .x != 0) >= 2))
    
    if (ncol(valid_genes) < 2) {
      print("    Not enough genes for correlation analysis.")
      next
    }

    print(paste("    Number of valid genes:", ncol(valid_genes)))  # Debugging

    corr_data <- compute_correlation(valid_genes)
    if (!is.null(corr_data) && nrow(corr_data) > 1) {
        num_significant <- sum(corr_data$significance != "NS")
        print(paste("    Significant correlations found:", num_significant))  # Debugging

        if (num_significant > 0) {
          p <- ggplot(corr_data, aes(Var1, Var2, fill = value)) +
            geom_tile(color = 'black') +
            geom_text(aes(label = significance), color = "black", size = 4) +  
            scale_fill_gradient2(low = "blue", mid = "white", high = "red", midpoint = 0) +
            theme_minimal() +
            labs(title = paste("Season:", season),
                 fill = "Correlation") +
            theme(plot.title = element_text(size = 10),
                  legend.position = 'null')

          plot_list[[season]] <- p
        }
    } else {
        print("    No valid correlation matrix returned.")
    }
  }

  # Arrange plots only if there are valid ones
  num_plots <- length(plot_list)
  print(paste("  Total plots for", genome, ":", num_plots))  # Debugging

  if (num_plots > 0) {
    panel_plot <- wrap_plots(plot_list, ncol = min(num_plots, 3)) +  
      plot_annotation(title = paste("Correlation Heatmaps for", genome)) 

    filename <- paste0(output_dir, "/heatmap_", genome, ".jpeg")
    ggsave(filename = filename, plot = panel_plot, width = 4 * min(num_plots, 3), height = 4)
    print(paste("  Saved heatmap:", filename))  # Debugging
  } else {
    print(paste("  No heatmap saved for genome:", genome))
  }
}

```

Same as for sites. I don't see correlation or pattern when I use the individual.abundance dataset. I kept 10 genomes (normalized genomes) since they have: - enough genes for a comparison - show some correlation (negative of positive) - some of them share patterns.

Do I see the same genomes between the three analysis?

## Heatmap based on single genomes and dipendent from site and season

```{r Heatmap based on single genomes and dipendent from site and season, include=FALSE }
#| eval: false
# Function to compute correlation and significance (unchanged)
compute_correlation <- function(df) {
  cor_matrix <- cor(df, use = "pairwise.complete.obs")
  p_matrix <- matrix(NA, nrow = ncol(df), ncol = ncol(df))
  colnames(p_matrix) <- rownames(p_matrix) <- colnames(df)
  
  for (i in 1:(ncol(df) - 1)) {
    for (j in (i + 1):ncol(df)) {
      test <- cor.test(df[[i]], df[[j]], method = "pearson")
      p_matrix[i, j] <- test$p.value
      p_matrix[j, i] <- test$p.value
    }
  }
  
  melted_corr <- reshape2::melt(cor_matrix)
  melted_pvals <- reshape2::melt(p_matrix)
  melted_corr$pval <- melted_pvals$value
  melted_corr$significance <- ifelse(is.na(melted_corr$pval), "", 
                                   ifelse(melted_corr$pval < 0.001, "***", 
                                          ifelse(melted_corr$pval < 0.01, "**", 
                                                 ifelse(melted_corr$pval < 0.05, "*", ""))))

  return(melted_corr)
}

# Split data by genome, site, and season (unchanged)
df_list <- split(df_season, list(df_season$genome, df_season$site, df_season$season), drop = TRUE)

# Rename list elements to keep only the genome name with version (unchanged)
names(df_list) <- sub(" ", "_", names(df_list))  # Ensure no spaces

# Directory to save plots (unchanged)
output_dir <- "heatmaps_site_season_dependent_norm"
dir.create(output_dir, showWarnings = FALSE)

# Initialize an empty list to store the plots (unchanged)
all_plots <- list()

# Loop through genomes and site-season combinations
for (genome_key in names(df_list)) {
  df_genome <- df_list[[genome_key]]

  # Extract genome info from genome_key (e.g., GCA_000307935.1)
  split_values <- unlist(regmatches(genome_key, gregexpr("[^\\.]+", genome_key)))
  genome <- paste(split_values[1:2], collapse = ".")  # Extract genome part (e.g., GCA_000307935.1)
  
  # Generate list of unique site-season combinations
  site_seasons <- unique(df_genome %>%
                           mutate(site_season = paste(site, season, sep = "_")) %>%
                           pull(site_season))

  # Initialize a flag to check if prd has any significant correlations
  prd_significant <- FALSE

  # Loop through site-season combinations
  for (site_season in site_seasons) {
    split_values <- unlist(strsplit(site_season, "_"))
    site_tmp <- split_values[1]
    season_tmp <- split_values[2]

    # Filter the dataframe for this site-season
    df_subset <- df_genome %>%
      filter(as.character(site) == as.character(site_tmp) & 
             as.character(season) == as.character(season_tmp)) %>%
      select(-genome, -season, -site, -day)

    if (nrow(df_subset) == 0) next  # Skip if no data left

    # Check if there are enough valid genes for correlation
    valid_genes <- df_subset %>%
      select(where(~ sum(!is.na(.x) & .x != 0) >= 2))
    
    if (ncol(valid_genes) < 2) next  # Skip if not enough valid genes

    # Compute correlation with error handling
    corr_data <- tryCatch({
      compute_correlation(valid_genes)
    }, error = function(e) {
      message(paste("Error in computing correlation for", genome, site_tmp, season_tmp, ": ", e$message))
      return(NULL)  # Return NULL if there is an error
    })
    
    if (!is.null(corr_data) && nrow(corr_data) > 1) {
      # Check if prd has any significant correlations
      if ("prd" %in% corr_data$Var1 || "prd" %in% corr_data$Var2) {
        prd_significant <- any(corr_data$significance[corr_data$Var1 == "prd" | corr_data$Var2 == "prd"] != "")
      }

      # If prd is significant, save all plots for this genome
      if (prd_significant) {
        num_significant <- sum(corr_data$significance != "")

        if (num_significant >= 0) {
          # Create the heatmap plot
          p <- ggplot(corr_data, aes(Var1, Var2, fill = value)) +
            geom_tile(color = 'black') +
            geom_text(aes(label = significance), color = "black", size = 4) +  
            scale_fill_gradient2(low = "blue", mid = "white", high = "red", midpoint = 0) +
            theme_minimal() +
            labs(title = paste(genome, "- Site:", site_tmp, "- Season:",
            season_tmp),
                 fill = "Correlation", y = '', x = '') +
            theme(plot.title = element_text(size = 6),
                  legend.position = 'null',
                  axis.text.x = element_text(angle = 90, hjust = 1, size = 5),
                  axis.text.y = element_text(hjust = 1, size = 5))
          
          filename <- paste0(output_dir, "/heatmap_", genome, "_site", site_tmp, "_season", season_tmp, ".jpeg")
          ggsave(filename = filename, plot = p, width = 4 * min(num_plots, 3), height = 4)
          
          # Store the plot in the list with a descriptive name
          plot_name <- paste(genome, site_tmp, season_tmp, sep = "_")
          all_plots[[plot_name]] <- p
          
          # Optional: print the name of the plot stored
          print(paste("Stored plot:", plot_name))  # Debugging message
        }
      }
    }
  }
}
```

```{r Reorganize the plots from the previous chunk, include=FALSE }
#| eval: false
# Extract genome names correctly (everything up to the second dot or first underscore after "GCA_")
genome_groups <- unique(str_extract(names(all_plots), "^GCA_\\d+\\.\\d+"))

# Create a named list to store grouped plots
grouped_plots <- setNames(vector("list", length(genome_groups)), genome_groups)

# Populate the list with grouped plots
for (genome in genome_groups) {
  grouped_plots[[genome]] <- all_plots[str_detect(names(all_plots), paste0("^", genome, "_"))]
}


# Plot each genome's heatmaps together
for (genome in names(grouped_plots)) {
  combined_plot <- wrap_plots(grouped_plots[[genome]]) + plot_layout(guides = "collect")
  print(combined_plot)
}

# merge table with phylum and family
genome_info <- df_season %>%
  inner_join(individual.abundance %>% select(genome, family) %>% distinct(genome, .keep_all= TRUE), join_by(genome))

# Group by family and create a list column for genomes
grouped_by_family <- genome_info %>%
  group_by(family) %>%
  summarise(genomes = list(genome), .groups = "drop")

# Create an empty list for storing grouped plots
plots_by_family <- list()

for (fam in grouped_by_family$family) {
  genomes_in_family <- grouped_by_family %>% 
    filter(family == fam) %>% 
    pull(genomes) %>% 
    .[[1]]  # Extract the genome list
  
  # Check if genomes_in_family is empty
  if (length(genomes_in_family) == 0) {
    message("Skipping family ", fam, " as no genomes found.")
    next  # Skip to the next family if there are no genomes
  }
  
  # Filter plots for this family and order them
  plots_in_family <- all_plots[str_detect(names(all_plots), paste(genomes_in_family, collapse = "|"))]
  
  # Sort plots based on site & season order
  ordered_plots <- plots_in_family[order(
    match(str_extract(names(plots_in_family), "(?<=_)(Offshore|Coast|Mesocosm)"), site_order),
    match(str_extract(names(plots_in_family), "(Winter|Spring|Summer)$"), season_order)
  )]
  
  # Store in list
  plots_by_family[[fam]] <- ordered_plots
}

# Remove empty families
plots_by_family <- plots_by_family[lengths(plots_by_family) > 0]

# Generate plots
for (fam in names(plots_by_family)) {
  combined_plot <- wrap_plots(plots_by_family[[fam]]) + plot_layout(guides = "collect")  + 
  plot_annotation(title = fam )
  
  print(combined_plot)
}

```

Grouping by family it looks like one can see correlation - Pelagibacteriaceae - Flavobacteriaceae - Thioglobaceae

I grouped based on when prd was significant but it doesn't mean tha if I use all the other data I can't find similar pattern.

```{r plot the grouped heatmaps, include=FALSE }
#| eval: false
# Although Prd is significant in one plot, it doesn't look intresting becaouse 
# it doesn't show any pattern
GCA_000307935 <- all_plots[["GCA_000307935.1_Coast_Winter"]] + 
all_plots[["GCA_000307935.1_Coast_Spring"]] + 
all_plots[["GCA_000307935.1_Mesocosm_Winter"]] + all_plots[["GCA_000307935.1_Mesocosm_Spring"]] + plot_annotation(title = "GCA_000307935 - D2472 (Gamma)")

#Save plot
ggsave('./heatmaps_site_season_dependent_no_norm/Heatmap_GCA_000307935_site_season.jpeg', GCA_000307935, height = 4)


# Many genes shows patter, but no significance with Prd
GCA_003279685 <- all_plots[["GCA_003279685.1_Offshore_Winter"]] +
all_plots[["GCA_003279685.1_Offshore_Spring"]] + 
all_plots[["GCA_003279685.1_Offshore_Summer"]] + 
all_plots[["GCA_003279685.1_Mesocosm_Winter"]] +
all_plots[["GCA_003279685.1_Mesocosm_Spring"]] +
all_plots[["GCA_003279685.1_Mesocosm_Summer"]] + plot_annotation(title = "GCA_003279685 - Pelagibacteraceae")

#Save plot
ggsave('./heatmaps_site_season_dependent_no_norm/Heatmap_GCA_003279685_site_season.jpeg', GCA_003279685, height = 4)

# No significante, no pattern, no interesting.
GCA_003283905 <- all_plots[["GCA_003283905.1_Offshore_Spring"]] / 
all_plots[["GCA_003283905.1_Offshore_Summer"]] + plot_annotation(title =  "GCA_003283905 - Pelagibacteraceae")

#Save plot
ggsave('./heatmaps_site_season_dependent_no_norm/Heatmap_GCA_003283905_site_season.jpeg', GCA_003283905, height = 4)

# Summer coast and spring are not relevant but there are patterns in Mesocosm
GCA_015665445 <- all_plots[["GCA_015665445.1_Offshore_Summer"]] + 
all_plots[["GCA_015665445.1_Coast_Summer"]] +
all_plots[["GCA_015665445.1_Mesocosm_Summer"]] +
all_plots[["GCA_015665445.1_Mesocosm_Winter"]] +
all_plots[["GCA_015665445.1_Coast_Spring"]] +
all_plots[["GCA_015665445.1_Mesocosm_Spring"]] +
plot_annotation(title =  "GCA_015665445 - Pseudohongiellaceae (Gamma)")

#Save plot
ggsave('./heatmaps_site_season_dependent_no_norm/Heatmap_GCA_015665445_site_season.jpeg', GCA_015665445, height = 4)

# No patter and only two plots from different site and seasons. No relevant.
GCA_000421325 <- all_plots[["GCA_000421325.1_Offshore_Summer"]] +
all_plots[["GCA_000421325.1_Mesocosm_Winter"]]  + plot_annotation(title =  "GCA_000421325 - AAA536-G10 (Alpha)")


#Save plot
ggsave('./heatmaps_site_season_dependent_no_norm/Heatmap_GCA_000421325_site_season.jpeg', GCA_000421325, height = 4)

# Pattern and comparable plots bother summer , Mesocosm and Coast
GCA_023263515 <- all_plots[["GCA_023263515.1_Coast_Summer"]] + 
all_plots[["GCA_023263515.1_Mesocosm_Summer"]] + plot_annotation(title =  "GCA_023263515 - Alteromonadaceae (Gamma)")

#Save plot
ggsave('./heatmaps_site_season_dependent_no_norm/Heatmap_GCA_023263515_site_season.jpeg', GCA_023263515, height = 4)

# Same as before, good pattern both summer, mesocosm and coast
GCA_024640565 <- all_plots[["GCA_024640565.1_Coast_Summer"]] + 
all_plots[["GCA_024640565.1_Mesocosm_Summer"]] + plot_annotation(title =  "GCA_024640565 - Flavobacteriaceae")


#Save plot
ggsave('./heatmaps_site_season_dependent_no_norm/Heatmap_GCA_024640565_site_season.jpeg', GCA_024640565, height = 4)

# Good genome with good comparable plots.
GCA_902560015 <- all_plots[["GCA_902560015.1_Offshore_Spring"]] +
all_plots[["GCA_902560015.1_Offshore_Summer"]] + 
all_plots[["GCA_902560015.1_Mesocosm_Spring"]] +
all_plots[["GCA_902560015.1_Mesocosm_Summer"]] + plot_annotation(title =  "GCA_902560015 - Pelagibacteraceae")


#Save plot
ggsave('./heatmaps_site_season_dependent_no_norm/Heatmap_GCA_902560015_site_season.jpeg', GCA_902560015, height = 4)

# Different season and different sites. not comparable
GCA_902572975 <- all_plots[["GCA_902572975.1_Offshore_Spring"]] + 
  all_plots[["GCA_902572975.1_Coast_Winter"]] +
  all_plots[["GCA_902572975.1_Mesocosm_Summer"]] + plot_annotation(title =  "GCA_902572975 - SAR86 (Gamma)")

#Save plot
ggsave('./heatmaps_site_season_dependent_no_norm/Heatmap_GCA_902572975_site_season.jpeg', GCA_902572975, height = 4)

# It's hard to say something
GCA_016776875 <- all_plots[["GCA_016776875.1_Mesocosm_Winter"]] + all_plots[["GCA_016776875.1_Mesocosm_Spring"]] +
all_plots[["GCA_016776875.1_Mesocosm_Summer"]] +
all_plots[["GCA_016776875.1_Coast_Winter"]] +
all_plots[["GCA_016776875.1_Offshore_Spring"]] + 
plot_annotation(title =  "GCA_016776875 - UBA868 (Gamma)")

#Save plot
ggsave('./heatmaps_site_season_dependent_no_norm/Heatmap_GCA_016776875_site_season.jpeg', GCA_016776875, height = 4)

# Many plots, maybe put them in different order so it's easy to read
GCA_024643905 <- all_plots[["GCA_024643905.1_Offshore_Spring"]] +
all_plots[["GCA_024643905.1_Coast_Spring"]] +
all_plots[["GCA_024643905.1_Mesocosm_Spring"]] +
all_plots[["GCA_024643905.1_Offshore_Summer"]] +
all_plots[["GCA_024643905.1_Coast_Summer"]] +
all_plots[["GCA_024643905.1_Mesocosm_Summer"]] +  plot_annotation(title =  "GCA_024643905 - HTCC2089 (Gamma)")

#Save plot
ggsave('./heatmaps_site_season_dependent_no_norm/Heatmap_GCA_024643905_site_season.jpeg', GCA_024643905, height = 4)

# Weird genome, it's worth it to keep an eye on it.
GCA_902556275 <-
all_plots[["GCA_902556275.1_Coast_Winter"]] +
all_plots[["GCA_902556275.1_Coast_Spring"]] +
all_plots[["GCA_902556275.1_Coast_Summer"]] +
all_plots[["GCA_902556275.1_Mesocosm_Spring"]] +
all_plots[["GCA_902556275.1_Offshore_Summer"]] + 
all_plots[["GCA_902556275.1_Mesocosm_Summer"]] + plot_annotation(title =  "GCA_902556275 - Thioglobaceae (Gamma)")

#Save plot
ggsave('./heatmaps_site_season_dependent_no_norm/Heatmap_GCA_902556275_site_season.jpeg', GCA_902556275, height = 4)

# Good comparison among summer sites. No relevant apart from Mesocosm summer
GCA_024638065 <- all_plots[["GCA_024638065.1_Offshore_Summer"]] + all_plots[["GCA_024638065.1_Coast_Summer"]] +
all_plots[["GCA_024638065.1_Mesocosm_Summer"]] +
plot_annotation(title =  "GCA_024638065 - Flavobacteriaceae")

#Save plot
ggsave('./heatmaps_site_season_dependent_no_norm/Heatmap_GCA_024638065_site_season.jpeg', GCA_024638065, height = 4)

# Comparison summer Offshore and Mesocosm. Correlation mdh and prd per Mesocosm.
GCA_016777325 <- all_plots[["GCA_016777325.1_Offshore_Summer"]] +
all_plots[["GCA_016777325.1_Mesocosm_Summer"]] + plot_annotation(title =  "GCA_016777325 - Flavobacteriaceae")

#Save plot
ggsave('./heatmaps_site_season_dependent_no_norm/Heatmap_GCA_016777325_site_season.jpeg', GCA_016777325, height = 4)

# Cluster together plot from same taxonomy group
# Gammaproteobacteria group 2
all_plots[["GCA_016776875.1_Mesocosm_Winter"]] + all_plots[["GCA_016776875.1_Mesocosm_Spring"]] +
all_plots[["GCA_016776875.1_Mesocosm_Summer"]] +
all_plots[["GCA_016776875.1_Coast_Winter"]] +
all_plots[["GCA_016776875.1_Offshore_Spring"]] + all_plots[["GCA_000307935.1_Coast_Winter"]] + 
all_plots[["GCA_000307935.1_Coast_Spring"]] + 
all_plots[["GCA_000307935.1_Mesocosm_Winter"]] + all_plots[["GCA_000307935.1_Mesocosm_Spring"]] + all_plots[["GCA_023263515.1_Coast_Summer"]] + 
all_plots[["GCA_023263515.1_Mesocosm_Summer"]] + all_plots[["GCA_902572975.1_Offshore_Spring"]] + 
all_plots[["GCA_902572975.1_Coast_Winter"]] +
all_plots[["GCA_902572975.1_Mesocosm_Summer"]] + plot_annotation(title = 'Gammaproteobacteria group 2') 

# Gamma group 1
( GCA_024643905 / GCA_902556275 / GCA_015665445 ) + plot_annotation( title = 'Gammaproteobacteria group 1')

# # Alphaproteobacteria
all_plots[["GCA_003279685.1_Offshore_Winter"]] +
all_plots[["GCA_003279685.1_Offshore_Spring"]] + 
all_plots[["GCA_003279685.1_Offshore_Summer"]] + 
all_plots[["GCA_003279685.1_Mesocosm_Winter"]] +
all_plots[["GCA_003279685.1_Mesocosm_Spring"]] +
all_plots[["GCA_003279685.1_Mesocosm_Summer"]] +
all_plots[["GCA_003283905.1_Offshore_Spring"]] +
all_plots[["GCA_003283905.1_Offshore_Summer"]] + all_plots[["GCA_902560015.1_Offshore_Spring"]] +
all_plots[["GCA_902560015.1_Offshore_Summer"]] + 
all_plots[["GCA_902560015._Mesocosm_Spring"]] +
all_plots[["GCA_902560015.1_Mesocosm_Summer"]] +
all_plots[["GCA_000421325.1_Offshore_Summer"]] +
all_plots[["GCA_000421325.1_Mesocosm_Winter"]] + plot_annotation(title = 'Alphaproteobacteria')

# # Pelagibacteraceae
GCA_003279685 / ( all_plots[["GCA_003283905.1_Offshore_Spring"]] +
all_plots[["GCA_003283905.1_Offshore_Summer"]] + all_plots[["GCA_902560015.1_Offshore_Spring"]] +
all_plots[["GCA_902560015.1_Offshore_Summer"]] + 
all_plots[["GCA_902560015._Mesocosm_Spring"]] +
all_plots[["GCA_902560015.1_Mesocosm_Summer"]]  )  + plot_annotation(title = 'Pelagibaceteriaceae')

# Flavobacteriaceae
all_plots[["GCA_024640565.1_Coast_Summer"]] + 
all_plots[["GCA_024640565.1_Mesocosm_Summer"]] + all_plots[["GCA_016777325.1_Offshore_Summer"]] +
all_plots[["GCA_016777325.1_Mesocosm_Summer"]] + all_plots[["GCA_024638065.1_Offshore_Summer"]] + all_plots[["GCA_024638065.1_Coast_Summer"]] +
all_plots[["GCA_024638065.1_Mesocosm_Summer"]] + plot_annotation(title = 'Flavobacteriaceae')
```

When I group the taxa together, there are interesing pattern and overall there are pattern shared among all the taxa. So far I couldn't see difference when plotting the data with individual.abundance dataset from counts.rhodo.genomes. So I can continue with one of the two.

## Try another approach for correlattion, pheatmap (clustering)

I will check with the next chunk if my data follow normal distribution

```{r check normal distribution across genes, include=FALSE }
#| eval: false
# Check how my data are distributed
df_season %>%
  group_by(season, site, genome) %>%
  filter(n() >= 3, sd(prd, na.rm = TRUE) > 0) %>% 
  summarise(p_value = shapiro.test(prd)$p.value, .groups = "drop")
  filter( p_value > 0.05)
# there are 282 obs that have normality patterns

# Try shapiro test on overall dataset.
shapiro.test(df_season$prd)  
# Overall p < 0.05 so no normality for prd + very few obs

# Plot the data to visualise normality
ggplot(df_season, aes(x = prd)) +
  geom_histogram(bins = 30, fill = "steelblue", alpha = 0.7) +
  theme_minimal()

ggplot(df_season, aes(sample = prd)) +
  stat_qq() + stat_qq_line()

```

SPOILER: it doesn't have normal distribution

```{r hieararchical clustering attempt, include=FALSE }
#| fig-height: 5
#| eval: false
library(pheatmap)
library(Polychrome)

# Create color palette based on the number of unique families
family_colors = glasbey.colors(length(unique(data$family)))
names(family_colors) <- unique(data$family)

for (season in unique(data$season)) {
  for (site in unique(data$site)) {
    
    # Subset data
    subset_data <- data %>%
      filter(season == !!season, site == !!site) %>%
      select(-season, -site, -day)

    # Extract family information before summarizing genomes
    family_info <- subset_data %>% select(genome, family) %>% distinct()

    # Summarize duplicates
    subset_data <- subset_data %>%
      group_by(genome) %>%
      summarise(across(where(is.numeric), mean, na.rm = TRUE)) %>%
      column_to_rownames("genome")

    # Merge back family info
    family_info <- family_info %>% filter(genome %in% rownames(subset_data))
    
    # Create annotation data frame
    annotation_df <- data.frame(Family = family_info$family)
    rownames(annotation_df) <- family_info$genome

    # Normalize gene expression
    subset_data <- scale(subset_data)

    # Generate heatmap with family annotations
    p <- pheatmap(subset_data, 
         clustering_distance_rows = "correlation",
         clustering_distance_cols = "correlation", # Use correlation-based distance
         clustering_method = "ward.D2",  # Keep Ward's method for clustering
         annotation_row = annotation_df,  # Add family info as row annotation
         annotation_colors = list(Family = family_colors),
         main = paste("Clustering -", site, "-", season))

    # Optional: save the plot
    output_file <- paste0("heatmap_", site, "_", season, ".png")
    ggsave(output_file, plot = p, width = 10, height = 8)
  }
}

```

Results: It looks like genes related to anaplerotic and biosinthesis are always linked while prd it is usually an outlier. it does cluster with some genes: - recA (not a good thing) - crtB crtI in Coast-Spring - idsA in mesocosm-Spring - pyc mdh in offshore-spring - glcB msh aceA in Coast-Summer - glcB in Mesocosm-Summer, Offshore-Summer, Mesocosm-Winter - no cluster Offshore-Winter

I will try a new approach

```{r Kruskal-Wallis test, include=FALSE }
#| eval: false
# Perform Kruskal-Wallis test for gene1 across seasons
kruskal_season <- kruskal.test(prd ~ season, data = df_season)
print(kruskal_season)

NO SIGNIFICANT

# Perform Kruskal-Wallis test for gene1 across sites
kruskal_site <- kruskal.test(prd ~ site, data = df_season))
print(kruskal_site)

SIGNIFICANT

library(dunn.test)

# If significant, perform Dunn's test for post-hoc analysis
dunn_result <- dunn.test(df_season$prd, df_season$site, method = "bonferroni")
print(dunn_result)

Significance between:
- Mesocosm-Coast
- Coast-Offshore


# Let's plot the results

ggplot(df_season, aes(x = site, y = prd, fill = site)) +
  geom_boxplot() +
  theme_minimal() +
  labs(title = "Gene Expression (prd) by Site", x = "Site", y = "Expression Level")

# Overall results show outliers pronounced in Coast
# Identify outliers in the Coast site
coast_outliers <- df_season %>%
  filter(site == "Coast" & prd > quantile(prd, 0.75) + 1.5 * IQR(prd))

# View the outliers
print(coast_outliers)
```

What I reach so far is that I have now a group of genomes that I want to use to track down whether environmental factors are involved in correlation prd and genes I found.

# Broad analysis of prd based on functional categories

```{r Functional categories cluster analysis, include=FALSE }
#| eval: false
# Group cog_categories
# Create a mapping table
category_mapping <- data.frame(
  cog_category = c("Cell_wall", "AA_metab", "NU", "Carbohy_metab", "Lipid_metab", 
                   "Energy_prod", "Post-transl_mod", "Transcription", "Tranlsation", 
                   "Signal_Transduc", "Intracel_traf", "Inorg_ion_transp", "Coenz_metab", 
                   "Sec_Structure", "Cell_cycle", "FP", "FG", "CF", "CM", "RNA_process", 
                   "Chromatin_Struc", "Func_unknown", "Cell_motility", "Cytoskeleton", 
                   "DNA_repair", "Stress_response", "Transporters", "Virulence", 
                   "Antibiotic_resistance", "Metabolic_pathways", "Enzyme_regulation", 
                   "Development", "Immune_response", "Photosynthesis", "Nitrogen_metab", 
                   "Sulfur_metab", "Phosphorus_metab", "Iron_metab", "Oxidative_stress", 
                   "Cell_division", "Cell_signaling", "Cell_adhesion", "Extracellular_matrix", 
                   "Hormone_metab", "Secondary_metab", "Toxin_production", "Symbiosis", 
                   "Quorum_sensing", "Biofilm_formation", "Chemotaxis", "Motility", 
                   "Secretion_systems", "Phage_related", "Transposable_elements", "Miscellaneous"),
  broad_category = c("Cell Wall and Membrane", "Amino Acid Metabolism", "Nucleotide Metabolism", 
                     "Carbohydrate Metabolism", "Lipid Metabolism", "Energy Production", 
                     "Post-Translational Modification", "Transcription", "Translation", 
                     "Signal Transduction", "Intracellular Trafficking", "Inorganic Ion Transport", 
                     "Coenzyme Metabolism", "Secondary Metabolism", "Cell Cycle", 
                     "Protein Folding and Processing", "Protein Folding and Processing", 
                     "Protein Folding and Processing", "Protein Folding and Processing", 
                     "RNA Processing", "Chromatin Structure", "Unknown Function", 
                     "Cell Motility", "Cytoskeleton", "DNA Repair and Recombination", 
                     "Stress Response", "Transporters", "Virulence and Pathogenicity", 
                     "Antibiotic Resistance", "Metabolic Pathways", "Enzyme Regulation", 
                     "Developmental Processes", "Immune Response", "Photosynthesis", 
                     "Nitrogen Metabolism", "Sulfur Metabolism", "Phosphorus Metabolism", 
                     "Iron Metabolism", "Oxidative Stress Response", "Cell Division", 
                     "Cell Signaling", "Cell Adhesion", "Extracellular Matrix", 
                     "Hormone Metabolism", "Secondary Metabolite Biosynthesis", 
                     "Toxin Production", "Symbiosis", "Quorum Sensing", "Biofilm Formation", 
                     "Chemotaxis", "Motility", "Secretion Systems", "Phage-Related Functions", 
                     "Transposable Elements", "Miscellaneous")
)

# Create a new dataset for this analysis
test <- counts.rhodo.genomes %>%
  select(genome, sample, day, season, site, cog_category, preferred_name, family) %>%
  inner_join(top50genomes %>% distinct(genome, .keep_all = TRUE), by = join_by(genome)) %>%
  left_join(category_mapping, by = "cog_category") %>%
  mutate(broad_category = ifelse(cog_category == "Func_unknown" & preferred_name == "prd", 
                                 "Energy Production", broad_category))

# Group genes by cog_category, but keep prd gene information
grouped_data <- test %>%
  group_by(broad_category) %>%
  mutate(contains_prd = "prd" %in% preferred_name) %>%
  ungroup()

# Filter data for functional categories that contain prd
prd_related_data <- grouped_data %>%
  filter(broad_category %in% prd_categories$broad_category)

prd_correlations <- prd_related_data %>%
  group_by(broad_category) %>%
  do({
    df <- .
    
    # Extract prd expression values (remove duplicates)
    prd_data <- df %>% 
      filter(preferred_name == "prd") %>% 
      select(sample, sum_tpm) %>%
      distinct(sample, .keep_all = TRUE)  # Ensure no duplicate samples for prd
    
    # If prd is missing, handle it by returning NA correlations
    if (nrow(prd_data) == 0) {
      cor_results <- df %>% 
        filter(preferred_name != "prd") %>% 
        distinct(sample, preferred_name) %>%
        mutate(
          correlation = NA,
          p_value = NA
        )
      return(cor_results)  # Return NA values for this category
    }
    
    # Join prd expression with other genes (remove duplicates)
    other_genes <- df %>% 
      filter(preferred_name != "prd") %>% 
      select(sample, preferred_name, sum_tpm) %>%
      distinct(sample, preferred_name, .keep_all = TRUE)  # Ensure no duplicates
    
    combined_data <- other_genes %>%
      left_join(prd_data, by = "sample", suffix = c("_gene", "_prd"))
    
    # Compute correlations
    cor_results <- combined_data %>%
      group_by(preferred_name) %>%
      summarize(
        correlation = if (is.na(sd(sum_tpm_gene, na.rm = TRUE)) || is.na(sd(sum_tpm_prd, na.rm = TRUE)) || 
                      sd(sum_tpm_gene, na.rm = TRUE) == 0 || sd(sum_tpm_prd, na.rm = TRUE) == 0) {
          NA  # Return NA if standard deviation is zero or cannot be computed
        } else {
          cor(sum_tpm_gene, sum_tpm_prd, use = "pairwise.complete.obs")
        },
        p_value = if (is.na(sd(sum_tpm_gene, na.rm = TRUE)) || is.na(sd(sum_tpm_prd, na.rm = TRUE)) || 
                   sd(sum_tpm_gene, na.rm = TRUE) == 0 || sd(sum_tpm_prd, na.rm = TRUE) == 0) {
          NA  # Return NA if standard deviation is zero or cannot be computed
        } else {
          cor.test(sum_tpm_gene, sum_tpm_prd, method = "pearson")$p.value
        }
      )
    
    cor_results
  })

# View the results
print(prd_correlations)


# It's time to visualize it

# Create a heatmap
ggplot(prd_correlations, aes(x = preferred_name, y = broad_category, fill = correlation)) +
  geom_tile(color = "black") +
  scale_fill_gradient2(low = "blue", mid = "white", high = "red", midpoint = 0, limits = c(-1, 1)) +
  labs(title = "Correlation of Genes with PRD by Functional Category",
       x = "Gene",
       y = "Functional Category",
       fill = "Correlation") +
  theme_minimal() +
  theme(axis.text.x = element_text(angle = 90, hjust = 1, size = 8),
        axis.text.y = element_text(size = 8))

# Filter data for a specific functional category (e.g., "Energy Production")
energy_data <- prd_related_data %>%
  filter(broad_category == "Energy Production")

# Create scatterplots
ggplot(energy_data, aes(x = sum_tpm, y = sum_tpm[preferred_name == "prd"], color = preferred_name)) +
  geom_point(alpha = 0.6) +
  facet_wrap(~ preferred_name, scales = "free") +
  labs(title = "Expression of PRD vs. Other Genes in Energy Production",
       x = "Gene Expression (TPM)",
       y = "PRD Expression (TPM)") +
  theme_minimal()
```

```{r wgcna analysis, include=FALSE }
#| eval: false
library(WGCNA)

# Prepare data for WGCNA (genes as rows, samples as columns)
wgcna_data <- prd_related_data %>%
  select(preferred_name, sample, sum_tpm) %>%
  spread(key = sample, value = sum_tpm) %>%
  column_to_rownames("preferred_name")

# Transpose the data for WGCNA
wgcna_data <- t(wgcna_data)

# Run WGCNA
powers <- c(1:10)
sft <- pickSoftThreshold(wgcna_data, powerVector = powers, verbose = 5)
softPower <- sft$powerEstimate

# Construct the network
net <- blockwiseModules(wgcna_data, power = softPower,
                        TOMType = "unsigned", minModuleSize = 30,
                        reassignThreshold = 0, mergeCutHeight = 0.25,
                        numericLabels = TRUE, pamRespectsDendro = FALSE,
                        saveTOMs = TRUE, saveTOMFileBase = "prd_TOM",
                        verbose = 3)

# Check which module prd belongs to
module_labels <- net$colors
prd_module <- module_labels["prd"]

# Extract genes in the same module as prd
prd_module_genes <- names(module_labels[module_labels == prd_module])

print(prd_module_genes)
```
